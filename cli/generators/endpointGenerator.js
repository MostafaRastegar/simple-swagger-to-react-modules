const fs = require("fs").promises;
const path = require("path");
const {
  formatCode,
  mapSwaggerTypeToTs,
  camelize,
  fileExists,
} = require("../utils");

/**
 * Updates or creates the endpoints.ts file.
 * @param {string} constantsDir - The directory for constants files.
 * @param {string} moduleName - The name of the module.
 * @param {object} swaggerJson - The parsed Swagger JSON.
 * @param {string} baseUrl - The base API URL.
 */
async function updateEndpointsFile(
  constantsDir,
  moduleName,
  swaggerJson,
  baseUrl
) {
  const endpointFileName = "endpoints.ts";
  const endpointFilePath = path.join(constantsDir, endpointFileName);
  const moduleConstantName = moduleName.toUpperCase();

  let currentEndpoints = {};

  if (await fileExists(endpointFilePath)) {
    try {
      const existingContent = await fs.readFile(endpointFilePath, "utf-8");
      const match = existingContent.match(
        /export const endpoints\s*=\s*({[\s\S]*});/
      );
      if (match && match[1]) {
        const objectContent = match[1]
          .replace(/\/\*[\s\S]*?\*\//g, "") // Remove block comments
          .replace(/\/\/.*$/gm, "") // Remove line comments
          .replace(/:.*?(?=[,)])/g, "") // Remove all type annotations including generics
          .replace(/\?/g, "") // Remove optional markers
          .trim();
        try {
          // Use a safer approach to parse the endpoints object
          currentEndpoints = new Function(`return ${objectContent};`)();
        } catch (e) {
          console.warn(
            `Could not parse existing endpoints object in ${endpointFilePath}, starting fresh for merge. Error: ${e.message}`
          );
          currentEndpoints = {};
        }
      }
    } catch (parseError) {
      console.warn(
        `Error reading or parsing existing endpoints.ts: ${parseError}. Starting fresh.`
      );
      currentEndpoints = {};
    }
  }

  const newModuleEndpoints = generateModuleEndpointsSwagger(
    moduleName,
    swaggerJson,
    baseUrl
  );

  currentEndpoints[moduleConstantName] = JSON.parse(newModuleEndpoints);

  let endpointsTsContent =
    `// Auto-generated by swagger-to-ddd\n` +
    `// This file is overwritten on each generation run for the specified module.\n` +
    `// Manual changes to other modules might be lost.\n` +
    `const BASE_URL = \"${baseUrl}\";\n\n` +
    `export const endpoints = {\n`;

  for (const [constName, moduleEndpoints] of Object.entries(currentEndpoints)) {
    endpointsTsContent += `  ${constName}: {\n`;
    for (const [endName, endPath] of Object.entries(moduleEndpoints)) {
      if (typeof endPath === "string" && endPath.startsWith("(")) {
        // This is a function endpoint
        endpointsTsContent += `    ${endName}: ${endPath},\n`;
      } else if (
        typeof endPath === "string" &&
        endPath.includes("${BASE_URL}")
      ) {
        endpointsTsContent += `    ${endName}: ${endPath},\n`;
      } else {
        endpointsTsContent += `    ${endName}: \`\${BASE_URL}${endPath}\`,\n`;
      }
    }
    endpointsTsContent += `  },\n`;
  }
  endpointsTsContent += `};\n`;

  const finalContent = await formatCode(endpointsTsContent, "typescript");
  await fs.writeFile(endpointFilePath, finalContent);
}

/**
 * Generates endpoint definitions for a specific module from Swagger JSON.
 * @param {string} moduleName - The name of the module.
 * @param {object} swaggerJson - The parsed Swagger JSON.
 * @param {string} baseUrl - The base API URL.
 * @returns {string} JSON string of endpoint definitions.
 */
function generateModuleEndpointsSwagger(moduleName, swaggerJson, baseUrl) {
  const paths = swaggerJson.paths || {};
  const basePath = swaggerJson.basePath || "";
  const moduleConstantName = moduleName.toUpperCase();
  let endpointDefinitions = {};

  for (const [pathUrl, pathItem] of Object.entries(paths)) {
    const effectivePath = pathUrl.startsWith("/")
      ? pathUrl.substring(1)
      : pathUrl;
    const pathSegments = effectivePath.split("/");
    const relevantSegmentIndex = basePath
      ? pathSegments.findIndex((seg) => seg === moduleName.split("/")[0])
      : pathSegments.findIndex((seg) => seg === moduleName);

    if (relevantSegmentIndex !== -1) {
      for (const [method, operation] of Object.entries(pathItem)) {
        if (["get", "post", "put", "delete"].includes(method)) {
          const httpMethod = method.toUpperCase();

          // Process path segments for new naming convention
          const pathSegments = pathUrl.substring(1).split("/"); // Removes leading '/' and splits
          const processedPathSegments = pathSegments.map((segment) => {
            if (segment.startsWith("{") && segment.endsWith("}")) {
              // It's a path parameter, e.g., {petId} or {id}
              const paramName = segment.slice(1, -1); // Extract 'petId' or 'id'
              return paramName.toUpperCase(); // e.g., 'PETID' or 'ID'
            } else {
              // It's a regular path segment, e.g., 'pet' or 'uploadImage'
              // Handle camelCase by inserting underscore before capital letters
              return segment
                .replace(/([a-z])([A-Z])/g, "$1_$2") // e.g., 'uploadImage' -> 'upload_Image'
                .toUpperCase(); // e.g., 'UPLOAD_IMAGE'
            }
          });

          const endpointNameSuffix = processedPathSegments.join("_"); // Join with underscores
          const finalEndpointName = `${httpMethod}_${endpointNameSuffix}`;

          const allParams = operation.parameters || [];
          const pathParams = allParams.filter((p) => p.in === "path");
          const queryParams = allParams.filter((p) => p.in === "query");

          // Create path template with BASE_URL first
          let pathTemplate = pathUrl;
          if (pathParams.length > 0) {
            for (const param of pathParams) {
              const regex = new RegExp(`\\{${param.name}\\}`, "g");
              pathTemplate = pathTemplate.replace(regex, `\${${param.name}}`);
            }
          }

          // Create function signature parameters (only path params and query params actually used in URL)
          let paramNames = [];
          for (const param of allParams) {
            if (param.in === "path") {
              // Path parameters are always included as they are required for URL construction
              const isOptional = !param.required;
              const paramType = mapSwaggerTypeToTs(
                param,
                swaggerJson.definitions || {}
              );
              paramNames.push(
                `${param.name}${isOptional ? "?" : ""}: ${paramType}`
              );
            } else if (param.in === "query") {
              // Only include query parameters if they are actually used in the URL template
              // Check if the parameter name appears in the path template
              if (
                pathTemplate.includes(`{${param.name}}`) ||
                pathTemplate.includes(`$${param.name}`)
              ) {
                const isOptional = !param.required;
                const paramType = mapSwaggerTypeToTs(
                  param,
                  swaggerJson.definitions || {}
                );
                paramNames.push(
                  `${param.name}${isOptional ? "?" : ""}: ${paramType}`
                );
              }
            }
          }

          // Create function body for the endpoint URL generator
          const functionBody = `return \`\${BASE_URL}${pathTemplate}\`;`;
          const functionSignature = `(${paramNames.join(", ")}) => { ${functionBody} }`;

          endpointDefinitions[finalEndpointName] = functionSignature;
        }
      }
    }
  }

  if (Object.keys(endpointDefinitions).length === 0) {
    console.warn(
      `No endpoints found for module '${moduleName}' in Swagger paths.`
    );
  }

  // Convert to JSON-safe format for stringification
  const stringifiedEndpoints = {};
  for (const [key, value] of Object.entries(endpointDefinitions)) {
    stringifiedEndpoints[key] = value;
  }

  return JSON.stringify(stringifiedEndpoints, null, 2);
}

module.exports = {
  updateEndpointsFile,
  generateModuleEndpointsSwagger,
};
