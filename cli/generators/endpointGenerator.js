const fs = require("fs").promises;
const path = require("path");
const {
  formatCode,
  mapSwaggerTypeToTs,
  camelize,
  fileExists,
} = require("../utils");

/**
 * Updates or creates the endpoints.ts file.
 * @param {string} constantsDir - The directory for constants files.
 * @param {string} moduleName - The name of the module.
 * @param {object} swaggerJson - The parsed Swagger JSON.
 * @param {string} baseUrl - The base API URL.
 */
async function updateEndpointsFile(
  constantsDir,
  moduleName,
  swaggerJson,
  baseUrl
) {
  const endpointFileName = "endpoints.ts";
  const endpointFilePath = path.join(constantsDir, endpointFileName);
  const moduleConstantName = moduleName.toUpperCase();

  let existingContent = "";
  let existingBaseUrl = baseUrl;

  if (await fileExists(endpointFilePath)) {
    try {
      existingContent = await fs.readFile(endpointFilePath, "utf-8");

      // Extract BASE_URL from existing file
      const baseUrlMatch = existingContent.match(
        /const BASE_URL = ['"`]([^'"`]+)['"`];/
      );
      existingBaseUrl = baseUrlMatch ? baseUrlMatch[1] : baseUrl;

      console.log(
        `Found existing endpoints file, will preserve current modules`
      );
    } catch (parseError) {
      console.warn(
        `Error reading existing endpoints.ts: ${parseError}. Starting fresh.`
      );
      existingContent = "";
    }
  }

  const newModuleEndpoints = generateModuleEndpointsSwagger(
    moduleName,
    swaggerJson,
    baseUrl
  );

  // Generate the new module content
  const newModuleContent = generateModuleContent(
    moduleConstantName,
    newModuleEndpoints
  );

  let finalContent;

  if (existingContent) {
    // Check if this module already exists
    const moduleExists = existingContent.includes(`${moduleConstantName}:`);

    if (moduleExists) {
      // Replace existing module
      finalContent = replaceExistingModule(
        existingContent,
        moduleConstantName,
        newModuleContent
      );
    } else {
      // Add new module
      finalContent = appendNewModule(existingContent, newModuleContent);
    }
  } else {
    // Create new file
    finalContent =
      `// Auto-generated by swagger-to-ddd\n` +
      `// This file accumulates endpoints from all generated modules.\n` +
      `// New modules are appended, existing modules are preserved.\n` +
      `const BASE_URL = "${existingBaseUrl}";\n\n` +
      `export const endpoints = {\n` +
      `  ${newModuleContent}\n` +
      `};\n`;
  }

  const finalFormattedContent = await formatCode(finalContent, "typescript");
  await fs.writeFile(endpointFilePath, finalFormattedContent);
}

/**
 * Replace an existing module in the endpoints file
 */
function replaceExistingModule(content, moduleName, newModuleContent) {
  const moduleStartRegex = new RegExp(`(\\s*)${moduleName}:\\s*{`, "g");
  const moduleEndRegex = /(\s*},\s*\n)/g;

  let result = content;
  let lastEndIndex = 0;
  let match;

  // Find all module starts
  const moduleStarts = [];
  while ((match = moduleStartRegex.exec(content)) !== null) {
    moduleStarts.push({
      start: match.index,
      indent: match[1],
      match: match[0],
    });
  }

  // Find the module we want to replace
  const targetModule = moduleStarts.find((m) =>
    content.substr(m.start).startsWith(`${m.indent}${moduleName}:`)
  );
  if (!targetModule) {
    return appendNewModule(content, newModuleContent);
  }

  // Find the matching end brace
  let braceCount = 0;
  let startIndex = targetModule.start;
  let inTargetModule = false;

  for (let i = startIndex; i < content.length; i++) {
    if (content[i] === "{") {
      braceCount++;
      inTargetModule = true;
    } else if (content[i] === "}") {
      braceCount--;
      if (inTargetModule && braceCount === 0) {
        // Found the end of our target module
        const beforeModule = content.substring(0, startIndex);
        const afterModule = content.substring(i + 1);

        // Find the comma after the closing brace
        let commaIndex = i + 1;
        while (commaIndex < content.length && content[commaIndex] !== ",") {
          commaIndex++;
        }

        const finalAfterModule = content.substring(commaIndex + 1);

        return (
          beforeModule +
          targetModule.indent +
          newModuleContent +
          finalAfterModule
        );
      }
    }
  }

  // If we couldn't find the end, just append
  return appendNewModule(content, newModuleContent);
}

/**
 * Append a new module to the endpoints file
 */
function appendNewModule(content, newModuleContent) {
  // Find the position of the closing brace of the endpoints object
  const lastBraceIndex = content.lastIndexOf("}");
  if (lastBraceIndex !== -1) {
    // Check if there's already a comma after the last module (before the closing brace)
    let insertIndex = lastBraceIndex;
    let hasTrailingComma = false;

    // Look backwards from the closing brace to find if there's a trailing comma
    for (let i = lastBraceIndex - 1; i >= 0; i--) {
      if (content[i] === "," || content[i].trim() === "") {
        continue;
      } else if (content[i] === "}") {
        // This is the closing brace we found
        hasTrailingComma = true;
        break;
      } else {
        // Found non-comma, non-whitespace character
        break;
      }
    }

    if (hasTrailingComma) {
      // There's already a comma, so just add the new module
      const beforeBrace = content.substring(0, lastBraceIndex);
      const afterBrace = content.substring(lastBraceIndex);
      return beforeBrace + `  ${newModuleContent}\n` + afterBrace;
    } else {
      // No trailing comma, so we need to add one and then the new module
      const beforeBrace = content.substring(0, lastBraceIndex);
      const afterBrace = content.substring(lastBraceIndex);
      return beforeBrace + `,\n  ${newModuleContent}\n` + afterBrace;
    }
  }

  // Fallback: just add to the end
  return content + `,\n  ${newModuleContent}`;
}

/**
 * Generate module content from JSON endpoints
 */
function generateModuleContent(moduleName, endpointsJson) {
  const endpoints = JSON.parse(endpointsJson);
  let content = `${moduleName}: {\n`;

  for (const [endpointName, endpointFunction] of Object.entries(endpoints)) {
    content += `    ${endpointName}: ${endpointFunction},\n`;
  }

  content += `  }`;
  return content;
}

/**
 * Generates endpoint definitions for a specific module from Swagger JSON.
 * @param {string} moduleName - The name of the module.
 * @param {object} swaggerJson - The parsed Swagger JSON.
 * @param {string} baseUrl - The base API URL.
 * @returns {string} JSON string of endpoint definitions.
 */
function generateModuleEndpointsSwagger(moduleName, swaggerJson, baseUrl) {
  const paths = swaggerJson.paths || {};
  const basePath = swaggerJson.basePath || "";
  const moduleConstantName = moduleName.toUpperCase();
  let endpointDefinitions = {};

  for (const [pathUrl, pathItem] of Object.entries(paths)) {
    const effectivePath = pathUrl.startsWith("/")
      ? pathUrl.substring(1)
      : pathUrl;
    const pathSegments = effectivePath.split("/");
    const relevantSegmentIndex = basePath
      ? pathSegments.findIndex((seg) => seg === moduleName.split("/")[0])
      : pathSegments.findIndex((seg) => seg === moduleName);

    if (relevantSegmentIndex !== -1) {
      for (const [method, operation] of Object.entries(pathItem)) {
        if (["get", "post", "put", "delete"].includes(method)) {
          const httpMethod = method.toUpperCase();

          // Process path segments for new naming convention
          const pathSegments = pathUrl.substring(1).split("/"); // Removes leading '/' and splits
          const processedPathSegments = pathSegments.map((segment) => {
            if (segment.startsWith("{") && segment.endsWith("}")) {
              // It's a path parameter, e.g., {petId} or {id}
              const paramName = segment.slice(1, -1); // Extract 'petId' or 'id'
              return paramName.toUpperCase(); // e.g., 'PETID' or 'ID'
            } else {
              // It's a regular path segment, e.g., 'pet' or 'uploadImage'
              // Handle camelCase by inserting underscore before capital letters
              return segment
                .replace(/([a-z])([A-Z])/g, "$1_$2") // e.g., 'uploadImage' -> 'upload_Image'
                .toUpperCase(); // e.g., 'UPLOAD_IMAGE'
            }
          });

          const endpointNameSuffix = processedPathSegments.join("_"); // Join with underscores
          const finalEndpointName = `${httpMethod}_${endpointNameSuffix}`;

          const allParams = operation.parameters || [];
          const pathParams = allParams.filter((p) => p.in === "path");
          const queryParams = allParams.filter((p) => p.in === "query");

          // Create path template with BASE_URL first
          let pathTemplate = pathUrl;
          if (pathParams.length > 0) {
            for (const param of pathParams) {
              const regex = new RegExp(`\\{${param.name}\\}`, "g");
              pathTemplate = pathTemplate.replace(regex, `\${${param.name}}`);
            }
          }

          // Create function signature parameters (only path params and query params actually used in URL)
          let paramNames = [];
          for (const param of allParams) {
            if (param.in === "path") {
              // Path parameters are always included as they are required for URL construction
              const isOptional = !param.required;
              const paramType = mapSwaggerTypeToTs(
                param,
                swaggerJson.definitions || {}
              );
              paramNames.push(
                `${param.name}${isOptional ? "?" : ""}: ${paramType}`
              );
            } else if (param.in === "query") {
              // Only include query parameters if they are actually used in the URL template
              // Check if the parameter name appears in the path template
              if (
                pathTemplate.includes(`{${param.name}}`) ||
                pathTemplate.includes(`$${param.name}`)
              ) {
                const isOptional = !param.required;
                const paramType = mapSwaggerTypeToTs(
                  param,
                  swaggerJson.definitions || {}
                );
                paramNames.push(
                  `${param.name}${isOptional ? "?" : ""}: ${paramType}`
                );
              }
            }
          }

          // Create function body for the endpoint URL generator
          const functionBody = `return \`\${BASE_URL}${pathTemplate}\`;`;
          const functionSignature = `(${paramNames.join(", ")}) => { ${functionBody} }`;

          endpointDefinitions[finalEndpointName] = functionSignature;
        }
      }
    }
  }

  if (Object.keys(endpointDefinitions).length === 0) {
    console.warn(
      `No endpoints found for module '${moduleName}' in Swagger paths.`
    );
  }

  // Convert to JSON-safe format for stringification
  const stringifiedEndpoints = {};
  for (const [key, value] of Object.entries(endpointDefinitions)) {
    stringifiedEndpoints[key] = value;
  }

  return JSON.stringify(stringifiedEndpoints, null, 2);
}

module.exports = {
  updateEndpointsFile,
  generateModuleEndpointsSwagger,
};
