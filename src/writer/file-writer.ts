const fs = require("fs-extra");
const path = require("path");

// Import global types
import { PackageJsonConfig, TsConfigConfig } from "../global-types";

/**
 * Writes generated code to the file system.
 */
class FileWriter {
  private outputDir: string;

  constructor(outputDir: string = "generated-frontend") {
    this.outputDir = outputDir;
    this.ensureOutputDir();
  }

  ensureOutputDir(): void {
    fs.ensureDirSync(this.outputDir);
    console.log(`Output directory ensured at: ${this.outputDir}`);
  }

  /**
   * Writes a TypeScript file.
   * @param {string} relativePath - Relative path within the output directory (e.g., 'models/User.ts').
   * @param {string} content - The TypeScript content to write.
   */
  writeTsFile(relativePath: string, content: string): void {
    const filePath = path.join(this.outputDir, relativePath);
    fs.ensureDirSync(path.dirname(filePath));
    fs.writeFileSync(filePath, content, "utf8");
    console.log(`File created: ${filePath}`);
  }

  /**
   * Writes multiple TypeScript files based on an object.
   * @param {Record<string, string>} files - An object where keys are relative paths and values are content.
   */
  writeTsFiles(files: Record<string, string>): void {
    for (const [relativePath, content] of Object.entries(files)) {
      this.writeTsFile(relativePath, content);
    }
  }

  /**
   * Writes a package.json file.
   * @param {PackageJsonConfig} packageJsonData - The data for package.json.
   */
  writePackageJson(packageJsonData: PackageJsonConfig): void {
    const packageJsonPath = path.join(this.outputDir, "package.json");
    fs.writeJsonSync(packageJsonPath, packageJsonData, { spaces: 2 });
    console.log(`File created: ${packageJsonPath}`);
  }

  /**
   * Writes a tsconfig.json file.
   * @param {TsConfigConfig} tsConfigData - The data for tsconfig.json.
   */
  writeTsConfigJson(tsConfigData: TsConfigConfig): void {
    const tsConfigPath = path.join(this.outputDir, "tsconfig.json");
    fs.writeJsonSync(tsConfigPath, tsConfigData, { spaces: 2 });
    console.log(`File created: ${tsConfigPath}`);
  }

  /**
   * Creates a README.md file for the generated project.
   * @param {string} projectName - Name of the generated project.
   * @param {string} [description="Generated frontend project from Swagger."] - Description of the generated project.
   */
  writeReadme(
    projectName: string,
    description: string = "Generated frontend project from Swagger."
  ): void {
    const readmeContent = `# ${projectName}

${description}

## Generated Files

This project was generated using the \`swagger-to-modules\` agent.

## Getting Started

1. Install dependencies:
   \`\`\`bash
   npm install
   \`\`\`

2. Start development (if applicable, e.g., if using a framework like Vue/Angle/React that has a dev server):
   \`\`\`bash
   npm start
   \`\`\`

   Or, if it's a library, build it:
   \`\`\`bash
   npm run build
   \`\`\`

## Usage

Import the generated modules into your application. For example:

\`\`\`typescript
import { UserService } from './services/UserService';
import { User } from './models/User';
\`\`\`

Note: You will need to configure \`axios\` (or your chosen HTTP client) with the base URL of your API.
This might involve setting \`axios.defaults.baseURL = 'YOUR_API_BASE_URL';\` in a central configuration file.

## Generated Code Overview

- \`models/\`: Contains TypeScript interfaces for your API data models.
- \`services/\`: Contains service classes for interacting with your API endpoints.
`;
    this.writeTsFile("README.md", readmeContent);
  }

  /**
   * Creates an index file to re-export commonly used modules.
   * @param {{ models?: string[]; services?: string[]; }} options - Configuration for index file.
   */
  writeIndexFile({
    models = [],
    services = [],
  }: { models?: string[]; services?: string[] } = {}): void {
    let indexContent = "// Generated by swagger-to-modules\n\n";

    if (models.length > 0) {
      indexContent += "// Models\n";
      models.forEach((model) => {
        const modelName = path.basename(model, path.extname(model));
        indexContent += `export * from './models/${model}';\n`;
      });
      indexContent += "\n";
    }

    if (services.length > 0) {
      indexContent += "// Services\n";
      services.forEach((service) => {
        const serviceName = path.basename(service, path.extname(service));
        indexContent += `export * from './services/${service}';\n`;
      });
    }
    this.writeTsFile("index.ts", indexContent);
  }

  /**
   * Generates a basic .gitignore for the output directory.
   */
  writeGitignore(): void {
    const gitignoreContent = `# Dependencies
node_modules/
.pnp
.pnp.js

# Testing
coverage/

# Production
build/
dist/

# Misc
npm-debug.log*
yarn-error.log*
*.log

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# next.js build output
.next

# nuxt.js build output
.nuxt

# vuepress build output
.vuepress/dist

# Serverless directories
.serverless

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db
`;
    this.writeTsFile(".gitignore", gitignoreContent);
  }
}

module.exports = FileWriter;
