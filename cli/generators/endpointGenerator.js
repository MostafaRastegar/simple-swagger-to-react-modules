const fs = require("fs").promises;
const path = require("path");
const {
  formatCode,
  mapSwaggerTypeToTs,
  camelize,
  fileExists,
} = require("../utils");

/**
 * Updates or creates the endpoints.ts file.
 * @param {string} constantsDir - The directory for constants files.
 * @param {string} moduleName - The name of the module.
 * @param {object} swaggerJson - The parsed Swagger JSON.
 * @param {string} baseUrl - The base API URL.
 */
async function updateEndpointsFile(
  constantsDir,
  moduleName,
  swaggerJson,
  baseUrl
) {
  const endpointFileName = "endpoints.ts";
  const endpointFilePath = path.join(constantsDir, endpointFileName);
  const moduleConstantName = moduleName.toUpperCase();

  let existingContent = "";
  let existingBaseUrl = baseUrl;

  if (await fileExists(endpointFilePath)) {
    try {
      existingContent = await fs.readFile(endpointFilePath, "utf-8");

      // Extract BASE_URL from existing file
      const baseUrlMatch = existingContent.match(
        /const BASE_URL = ['"`]([^'"`]+)['"`];/
      );
      existingBaseUrl = baseUrlMatch ? baseUrlMatch[1] : baseUrl;

      // Found existing endpoints file, will preserve current modules
    } catch (parseError) {
      console.warn(
        `Error reading existing endpoints.ts: ${parseError}. Starting fresh.`
      );
      existingContent = "";
    }
  }

  const newModuleEndpoints = generateModuleEndpointsSwagger(
    moduleName,
    swaggerJson,
    baseUrl
  );

  // Generate the new module content
  const newModuleContent = generateModuleContent(
    moduleConstantName,
    newModuleEndpoints
  );

  let finalContent;

  if (existingContent) {
    // Check if this module already exists
    const moduleExists = existingContent.includes(`${moduleConstantName}:`);

    if (moduleExists) {
      // Replace existing module
      finalContent = replaceExistingModule(
        existingContent,
        moduleConstantName,
        newModuleContent
      );
    } else {
      // Add new module
      finalContent = appendNewModule(existingContent, newModuleContent);
    }
  } else {
    // Create new file
    finalContent =
      `// Auto-generated by swagger-to-ddd\n` +
      `// This file accumulates endpoints from all generated modules.\n` +
      `// New modules are appended, existing modules are preserved.\n` +
      `const BASE_URL = "${existingBaseUrl}";\n\n` +
      `export const endpoints = {\n` +
      `  ${newModuleContent}\n` +
      `};\n`;
  }

  const finalFormattedContent = await formatCode(finalContent, "typescript");
  await fs.writeFile(endpointFilePath, finalFormattedContent);
}

/**
 * Replace an existing module in the endpoints file
 */
function replaceExistingModule(content, moduleName, newModuleContent) {
  const moduleStartRegex = new RegExp(`(\\s*)${moduleName}:\\s*{`, "g");
  const moduleEndRegex = /(\s*},\s*\n)/g;

  let result = content;
  let lastEndIndex = 0;
  let match;

  // Find all module starts
  const moduleStarts = [];
  while ((match = moduleStartRegex.exec(content)) !== null) {
    moduleStarts.push({
      start: match.index,
      indent: match[1],
      match: match[0],
    });
  }

  // Find the module we want to replace
  const targetModule = moduleStarts.find((m) =>
    content.substr(m.start).startsWith(`${m.indent}${moduleName}:`)
  );
  if (!targetModule) {
    return appendNewModule(content, newModuleContent);
  }

  // Find the matching end brace
  let braceCount = 0;
  let startIndex = targetModule.start;
  let inTargetModule = false;

  for (let i = startIndex; i < content.length; i++) {
    if (content[i] === "{") {
      braceCount++;
      inTargetModule = true;
    } else if (content[i] === "}") {
      braceCount--;
      if (inTargetModule && braceCount === 0) {
        // Found the end of our target module
        const beforeModule = content.substring(0, startIndex);
        const afterModule = content.substring(i + 1);

        // Find the comma after the closing brace
        let commaIndex = i + 1;
        while (commaIndex < content.length && content[commaIndex] !== ",") {
          commaIndex++;
        }

        const finalAfterModule = content.substring(commaIndex + 1);

        return (
          beforeModule +
          targetModule.indent +
          newModuleContent +
          finalAfterModule
        );
      }
    }
  }

  // If we couldn't find the end, just append
  return appendNewModule(content, newModuleContent);
}

/**
 * Append a new module to the endpoints file
 */
function appendNewModule(content, newModuleContent) {
  // Find the position of the closing brace of the endpoints object
  const endpointsCloseIndex = content.lastIndexOf("};");

  if (endpointsCloseIndex === -1) {
    // Fallback: just add to the end
    return content.replace(/};?$/, `  ${newModuleContent}\n};`);
  }

  // Insert the new module before the final };
  const beforeClosing = content.substring(0, endpointsCloseIndex);
  const closingBrace = content.substring(endpointsCloseIndex);

  // Find the last module to check if we need a comma
  const lastModuleBraceIndex = beforeClosing.lastIndexOf("}");

  if (lastModuleBraceIndex !== -1) {
    // Check what's between the last module brace and the endpoints close
    const betweenText = content
      .substring(lastModuleBraceIndex + 1, endpointsCloseIndex)
      .trim();

    // Find where to insert - right before the endpoints object's closing comma/braces
    let insertIndex = endpointsCloseIndex - 1; // Before the ;
    while (insertIndex >= 0 && content[insertIndex].trim() === "") {
      insertIndex--; // Skip whitespace
    }

    // Insert new module content right before the closing
    const result =
      content.substring(0, insertIndex + 1) +
      `\n  ${newModuleContent},` +
      content.substring(insertIndex + 1);

    return result;
  }

  // If we can't find module structure, use simple fallback
  console.log("DEBUG: Using simple fallback");
  return beforeClosing + `\n  ${newModuleContent}` + closingBrace;
}

/**
 * Generate module content from JSON endpoints
 */
function generateModuleContent(moduleName, endpointsJson) {
  const endpoints = JSON.parse(endpointsJson);
  let content = `${moduleName}: {\n`;

  for (const [endpointName, endpointFunction] of Object.entries(endpoints)) {
    content += `    ${endpointName}: ${endpointFunction},\n`;
  }

  content += `  }`;
  return content;
}

/**
 * Generates endpoint definitions for a specific module from Swagger JSON.
 * @param {string} moduleName - The name of the module.
 * @param {object} swaggerJson - The parsed Swagger JSON.
 * @param {string} baseUrl - The base API URL.
 * @returns {string} JSON string of endpoint definitions.
 */
function generateModuleEndpointsSwagger(moduleName, swaggerJson, baseUrl) {
  const paths = swaggerJson.paths || {};
  const basePath = swaggerJson.basePath || "";
  const moduleConstantName = moduleName.toUpperCase();
  let endpointDefinitions = {};

  for (const [pathUrl, pathItem] of Object.entries(paths)) {
    const effectivePath = pathUrl.startsWith("/")
      ? pathUrl.substring(1)
      : pathUrl;
    const pathSegments = effectivePath.split("/");
    const relevantSegmentIndex = basePath
      ? pathSegments.findIndex((seg) => seg === moduleName.split("/")[0])
      : pathSegments.findIndex((seg) => seg === moduleName);

    if (relevantSegmentIndex !== -1) {
      for (const [method, operation] of Object.entries(pathItem)) {
        if (["get", "post", "put", "delete"].includes(method)) {
          const httpMethod = method.toUpperCase();

          // Process path segments for new naming convention
          const pathSegments = pathUrl.substring(1).split("/"); // Removes leading '/' and splits
          const processedPathSegments = [];
          let skipNext = false;

          for (let i = 0; i < pathSegments.length; i++) {
            if (skipNext) {
              skipNext = false;
              continue;
            }

            const segment = pathSegments[i];
            if (!segment) continue; // Skip empty segments
            const nextSegment = pathSegments[i + 1];

            if (segment.startsWith("{") && segment.endsWith("}")) {
              // It's a path parameter, e.g., {petId} or {id}
              const paramName = segment.slice(1, -1); // Extract 'petId' or 'id'
              processedPathSegments.push(paramName.toUpperCase()); // e.g., 'PETID' or 'ID'
            } else {
              // Skip API version pattern (api/v1, api/v2, etc.)
              if (
                segment.toLowerCase() === "api" &&
                nextSegment &&
                /^v\d+$/.test(nextSegment)
              ) {
                skipNext = true; // Skip both api and v1 segments
              } else {
                // Regular path segment
                processedPathSegments.push(
                  segment
                    .replace(/([a-z])([A-Z])/g, "$1_$2") // Handle camelCase
                    .replace(/[^a-zA-Z0-9]/g, "_") // Replace hyphens and special chars with underscores
                    .toUpperCase()
                );
              }
            }
          }

          const endpointNameSuffix = processedPathSegments.join("_"); // Join with underscores
          const finalEndpointName = `${httpMethod}_${endpointNameSuffix}`;

          const allParams = operation.parameters || [];
          const pathParams = allParams.filter((p) => p.in === "path");
          const queryParams = allParams.filter((p) => p.in === "query");

          // Create path template with BASE_URL first
          let pathTemplate = pathUrl;
          if (pathParams.length > 0) {
            for (const param of pathParams) {
              const regex = new RegExp(`\\{${param.name}\\}`, "g");
              pathTemplate = pathTemplate.replace(regex, `\${${param.name}}`);
            }
          }

          // Create function signature parameters (only path params and query params actually used in URL)
          let paramNames = [];
          for (const param of allParams) {
            if (param.in === "path") {
              // Path parameters are always included as they are required for URL construction
              const isOptional = !param.required;
              const paramType = mapSwaggerTypeToTs(
                param,
                swaggerJson.definitions || {}
              );
              paramNames.push(
                `${param.name}${isOptional ? "?" : ""}: ${paramType}`
              );
            } else if (param.in === "query") {
              // Only include query parameters if they are actually used in the URL template
              // Check if the parameter name appears in the path template
              if (
                pathTemplate.includes(`{${param.name}}`) ||
                pathTemplate.includes(`$${param.name}`)
              ) {
                const isOptional = !param.required;
                const paramType = mapSwaggerTypeToTs(
                  param,
                  swaggerJson.definitions || {}
                );
                paramNames.push(
                  `${param.name}${isOptional ? "?" : ""}: ${paramType}`
                );
              }
            }
          }

          // Create function body for the endpoint URL generator
          const functionBody = `return \`\${BASE_URL}${pathTemplate}\`;`;
          const functionSignature = `(${paramNames.join(", ")}) => { ${functionBody} }`;

          endpointDefinitions[finalEndpointName] = functionSignature;
        }
      }
    }
  }

  if (Object.keys(endpointDefinitions).length === 0) {
    console.warn(
      `No endpoints found for module '${moduleName}' in Swagger paths.`
    );
  }

  // Convert to JSON-safe format for stringification
  const stringifiedEndpoints = {};
  for (const [key, value] of Object.entries(endpointDefinitions)) {
    stringifiedEndpoints[key] = value;
  }

  return JSON.stringify(stringifiedEndpoints, null, 2);
}

module.exports = {
  updateEndpointsFile,
  generateModuleEndpointsSwagger,
};
